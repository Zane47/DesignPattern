# 软件设计七大原则

* 开闭原则(所有原则, 设计模式的基础)

* 依赖倒置原则

* 单一职责原则
* 接口隔离原则
* 迪米特法则(最少知道原则)
* 里氏替换原则
* 合成/复用原则(组合/复用原则)

每个原则都有焦点, 开发的时候注重平衡人力和业务扩展性, 成本

设计模式中对这七大原则有取舍

## 开闭原则

### 概念

定义: 一个软件实体如类, 模块和函数应该**对扩展开放, 对修改关闭**

强调(中心思想): 用抽象构建框架, 用实现扩展细节

优点: 提高软件系统的可复用性以及可维护性

最基础的. 所有原则, 设计模式的基础. 尽量不修改源代码, 增加新功能

例子: 弹性工作制度: 对工作8h的时间是关闭的, 但是可以自己决定工作时间段

---

例如: 对于校验的业务逻辑, 校验中有顺序, 校验A -> 校验B -> 校验C

新增校验规则(扩展) -> 要开放, 尽量不修改原来的校验规则代码, 以免引入错误风险

**实现开闭原则的核心思想: 面向抽象编程**. 而不是面向实现编程, 抽象相对来说更加稳定, 让类依赖固定的抽象, 那么就是对修改封闭. 

而通过面向对象的继承多态的机制, 可以实现对抽象体的继承, 通过重写改变其固有方法, 或者实现新的扩展方法. 

变化发生时, 我们可以创建抽象来隔离以后有可能发生的同类变化, 核心在于实现抽象化, 怎么从业务场景中抽象出业务模型, 并且从抽象化得到具体化的实例.

### coding

开闭原则: 软件实现应该对扩展开放, 对修改关闭

中心思想: 用抽象构建框架, 用实现扩展细节

所有原则的基础, 包括设计模式, 通过设计模式可以解耦, 提交软件设计的扩展性

提高内聚, 降低耦合



---

3-3

一句话。软件实现应该对扩展开放，对修改关闭，那为什么说它是最重要的一个原则的？因为他是所有原则中的一个基础，包括后续的设计模式，那本身呢通过设计模式可以解耦。提高软件设计我的过我的过程中呢也可以进行微重构或者呢局部重构来提高我们软件系统的扩展性，提高内聚，降低耦合，那开闭原则的中心思想就是我们要用抽象来构建框架。实现呢扩展，那这些原则呢还比较抽象，我们的课程呢就是通过coding来解决这些问题，那现在呢我们一起来学习一下开闭原则，简单呐，举几个小例子，然后呢大家在从这个过程中进行体会，那我们这个项目呢是一个空的vivo项目不会再加上下边呀创建一包。Com点激励点design principle。Ok，那这个包呢就创建好了设计原则，ok，然后我们在里边呢穿哪个包？这个报名呢？因为是开闭原则，所以呢直接用open close，中间呢就不加点了，为了保证我们所有的原则呢都在这个方下边。那这，我们参考了jk里面的源码，源码的一个命名，比如说rt点大里面有个apple，apple呢这里面有一个iQOO然后算下边呢还有一个包，就包呢这样。这个呢不用纠结，继续待在多个单词形成一个报名的时候呢，我们也采用全小写不使用通风的方式，那我们呢也会结合前面所讲的ul来提高大家的理解，首先呢我们就以不可网为例吧，首先我们创建一个类，这个类呢要靠他那是个接口，那接口呢我们最好以i开头代表呢是一个接口ok。那我们课程里边呢是有ID的这个接口啊，可以返回这个课程的ID，那课程里边呢还有课程的名字。那这个呢也是一个方法在里边呢，还有一个价格。盖price，那正常来说呢，一个课程它是一个实体，我们可以呢去写一个类，然后呢会有ID内5 Pro这三个变量，但是呢我们是为了演示还比原则，但因为开闭原则呢比较抽象一些。我们这个例子呢是相对简单的一简单，那通过后续的一套课程呢，我们会对开学原则理解更深入，那我们的课程呢有很多类型有JAVA的，有算法呢，没有前端的，所以呢我们创建一个类。想JAVA ok。直线呢靠接口。然后我们来实现解决方法，在这个时间呢比较简单。声明ID声明名字。他的价格。Ok，那我们再写一个呢，全参构造器。选择在这里边呢。Face表加上那其实在刚刚这个环境啊点儿和不加s的是一样的，那下面那也是一样返回的ID。This may。就想那现在我们有一个测试函数就这样。这个快捷键是svm，然后呢一个就可以了，以后呢我们的测试内啊都用，那我们通过接口呢来指向一个实体类JAVA扣，为什么呢？Neo加瓦克。Ok，然后我们看的这个提示，第一个ID脑的第一门课程的ID呢是96，名字呢是JAVA从零到企业级电商开发。那它的价格呢是348二元。我们最大化一下，然后呢我们直接输出，那实际我们在写项目的时候啊，out的尽量不用，确切的说这个在实际项目中呢是禁止的，那因为呀那谁他们out的里面啊是有锁的，那我们现在呢只是说个调试讲解我们设计模式。我们就不引入包了，就直接用来调试理解，这个首先呢是课程ID。改ID，然后呢课程的名称然后呢是价格Friend到单位呢就是你们说一下，现在呢我们这个课程信息呀都正常输出了，我们来看一下现在的电结，然后呢放大一下那现在的类结构图啊，非常简单，这个呢是一个接口，这个是一个类，然后这个类实现接口非常清晰，那我们一定要善用idea里边的查看工具，让我们开源码的时候啊，非常有用，那这里边的显示呢会和之前讲的标准的ul的有一点小小的差异，例如这个i就代表他没有用棒棒糖表示法，也没有用监护号，但是呢我们能看出来，那这个呢它的类型ok，那现在的那结构啊非常简单，我们呢也正常输出了这个课程的信息。那么输出完这个课程信息之后啊，那现在呢不可网有活动了，比如说双十一还是呢618要进行一个打折活动，那我们怎么来开发这个需求呢？首先呢回到我们接口，那我们是不是要增加一个钙？Discount cry每个方法呢，ok，假设我们增加了这个方法，比如说这个呢是获取课程的原价，这个呢是获取课程的打折价格，那我们这个JAVA课程的这个类呢需要进行修改了，至少我要实现这个方法ok，那假设呢现在做活动打8折。可以的我们接我们接口呢是不应该经常变化的，他应该是稳定且可靠的，否则呢接口作为契约的这个作用就是失去了，那我们再换一种思路。我这个方法呀切掉k在这里边呢也自己的对的，就这个方式来说，我们获取这个原价，那恢复，那我们为什么最开始是一个接，在这里边呢也是为了演示我们要面向接口编程，然后继续来看我们这个类，这个时候呢我们想一下，我们如果通过扩展再写一个JAVA的子类呢来试一下。文新这一个位JAVA core ok。我这段换一下，他来继承JAVA号。那这个时候呢题是错误的，意思是说了在加COS里边没有默认的不能信，因为我们在这里边的并没有一个无餐的构造器ok，但是呢那个不重要，我们还是以课程的目标为准，ok。那默认idea给他实现呐，真调用父类的构造器，这个呢没有问题，那这里边呢为什么命名JAVA啊？因为它是一个JAVA打折的课程，那如果我们这个折扣非常简单，所有类型的课程呢都统一打折。我们这个命名，不叫JAVA，直接就叫打折的一个课程即可。那这里边呢就衍生一个叫红旗m，我们来重写一个override override什么呢类的方法，那这个呢默认生成的呢是点也就是说要用户类的这个方法啊，那我们这里边呢直接乘以0.8。那如果呢我们要做分期间加jJAVA号，JAVA的折扣课程，那这里边呢？这个原价我们说一下那这个课程那这个课那这个课程价格，售卖价格啊现在直接调用该price拿到的是一折后价，但是呢我们原价没有了，那很简单，我们还是回到这个类里边，我们写一个。Price你这什么呢是是JAVA，但是它的引用了是一个iQOO，所以我们在这里边想获取原价的时候，我们试一下。点ok并没有我们之前声明的price，虽然呢他现在是ok，那我们怎么办呀？很简单，什么bug来看一下，给大家看一长短长短，ok，他名字呢还叫这个。让下边的引用啊能动。把他的改一下就可以了。那这样呢我们就抢转成功了，然后我们这里边呢课程这个呢是折扣价格。前面那我们再加一下。原价还是加盖price ok到前面的加入空格方便呢，我们查看结果。我们转一下好，这个时候呢可以看到ID有了，课程名称有了，原价有了，折后价格也有了，ok，在这里边呢在强调一下啊，我们这个课程的重点呢并不是搞定这个double就是精度的问题。对的，这一块儿忽略就可以了，那解决方案呢，前边我也说过了，ok，那么现在呢来体会一下我们刚刚的这个做法，首先接口没有变。它的实现类也没有变ok，然后呢我们声明了一个主类来继承JAVA考，我们看一下包个小一下，所以呢看到这个箭头曲线呢是实现接口实现的是继承ok，而我们这个子类的构造器是调用的父类的构造器，而下面这个呢就是方法这两个方法，一个是还有呢，返回值是double price。那我们现在的打折销售给开发完工作中都是容易引起bug的而，而我们通过继承了一个积累，简单的一个方式，使我们对于这个扩展呢是开放的，而对修改这个接口和这个鸡肋呢是关闭的，ok，论文变化的呢都是应用层的一个子模块，比如说还有呢新增了就是呗，那因为越低层次的模块儿。基础的模块变化也都也都是开病原者的一个不过这不过这个文件或者呢变的配置方式，而不是去修改spring的源码。地主是二期当中我们通过我们我们后续呢还，不断的加强巩固，那随着我们课程的学习呢，大家对这几个原则呀理解也会越来越深的，那有一些设计模式呢，会和原则有一定冲突那其实就是一个，平衡的，问题，那这个呢到后面碰到我会再详细，说的

---

3-4

我们来学习依赖倒置原则首先呢，首先呢我们来看一下它的定义，高层模块不应该依赖基层文化，两者呢都应该依赖其抽象。第一的补充我们来看比如比如说每个类尽量都继承自接口或抽象类，在这里边呢说的比较泛化，也就是说你可以通过来实现接口，或者呢通过碳来继承一个抽象类，或者呢也可以继承抽象类，并且呢实现接口这个只能是说尽量尽量的避免从具体的类开。尽量的不要覆盖期积累的方法，那我们看一下依赖倒置原则的一个优点。可以减少那边的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并且呢最重要的还可以降低修改程序所造成的风险，那依赖导致原则呀，非常简单，我们通过coding就可以非常容易的理解。查了，那现在呢我们一起来吧，我们先创建一个包。X简单的说呢就是程序要依赖于抽象更好，不要依赖于具体的实现，它的主要目的呢就是降低耦合，那后边呢我们写完之后大家来体会一下，我们呢在这里边开车前，首先我们还是有这么一个场景，也就是说机理现在呢在顾客网上学习，我可能对JAVA的课程比较感兴趣，另外呢我对前端的课程我比较感兴趣，首先我们创建一个类叫那我们现在来实现方法。JAVA在。JAVA我们你里的学习前端的课程。再写一个测试类。1然后呢我来学习JAVA课程，学了之后呢我还要休息前段的课程。属兔这个速度啊非常，但现在我们的问题是什么呢？假设这个时候我还要学习Python的课程，那么我会在这里添加，那对于经理来说这个实体的方法呢是在不断补充的。那边写一个。S我们来体会一，现在我们的做法就是面相实现编程，因为整个机理就是一个实现类，我们在面向时间变长，会发现一个最重要的问题。这个时间内是要经常修改的，扩展性比较差，也就是说我们应用层的这个函数这里面的修改是依赖于底层实现的，因为我们没有。我想所以造成我们的应用层的这个类及函数呢是依个类的，因为这个类的应用层的他呢属于高层模块机里呢是属于第一层模块儿，因为现在呢只有这两个类，那根据依赖倒置的原则，高层次的模块是不应该依赖于一城市的模块儿的，也就是说test里边的实现现在依赖于伊利的具体实现里边实现什么我都要来。这里边扩展活动。然后在高层模块呢。还可以使用，那我们现在呢引入抽象看看来如何解决这个问题，首先我们创建一个类，这个类呢有接口吧iQOO还是课程在这个课程呢有个方法就是学习课程。具体学什么课程呢？我们交给高层模块的应用程来选择，那接下来呢也很简单，我们来写一个JAVA。嗯这个课程这里面实现的时，因为在开闭原则里边呀也使用了同样的类型，这边呢不要选错选择我们自己刚刚创建的之类，因为列名一样。现在呢实现了这个类，那这里面的输出啊，一例子里面的输出我们拿过来。然后呢我们再写一个。Se号。直线iQOO包那个检测要选这个刚刚创建的这个包。实现那个方法，然后呢这个实现啊拿过来。那拍摄的呢是一样的，我们这里边呢就不写了，那看一下我们地理这个类。那现在呢这三个具体的实现我们就可以干掉了我们看一下这个场景，大家都是比较熟悉了，我们实现一个方法study i这边呢？通过这个方反一个对象，而这个对象是要用接口的，因为具体我传课程还是JAVA课程呢，是要依据高层模块他的选择，这里边呢我们传一个QOO study，也就是说你在学习慕课网课程的时候，具体的时间内交给高层次核算，而不是针对伊犁这个时间内来编写，我们来看一下探索。这个呢我的钱都身上就认为呢它是一个飞机版本放在这儿，这样呢也会对。在接下来的时间怎么写呢？很简单，还是另一个地点，地点八ioc这里面又有一个JAVA口，我的另一个来转一下Ok，你说出来输出结果呢是一样的，但是呢写法都不一样的，我看一下例图。给他画一下。首先QOO这个接口放在这里边，那如果有其他的课程的实现，比如Python的课程ok和他们评级放在身边即可。而具体的地理这个类是不需要动的春节春节我的同时呢第一点和具体的课程直线是解耦的，但是呢他和iOS接口是有合的，那所谓的高内聚，低耦合，也就是说尽量减少和而因为有依赖关系比如说iOS是伊犁这个类的一个方法中的，参数所以呢他俩之间是，有关系，的所以，看到这个，内部就接下来的扩展就非常简单了，例如我们现在还想学习Python的课程。我来创建一个类。iQOO过来我们就实Python课程的各类，而对于高层模块与应用层的太子类，我想学习什么？通过心里边儿study course里面的参数注入进去。这样的话呢，我们看一下结果，那对于一个新的课程，我们只需要新建一个类，然后实现这个接口面向是否变长，然后具体学习哪个课程呢？交给应用层的探索的类。高层模块，那这个呢是通过接口方法的方式来注入具体的实现，那当然啦，我们也可以通过构造器的方式来注入10具体里面的实现。那现在呢我们写一个。iQOO我们在那里边呢在声明一个具体呢，它的线呢我们先忽略，用ok先放在这，在这里边呢小伙伴们是不是很熟悉呢？比如说的是注入我们通过在上面啊加一些细节做一些造成或者说的接口起来，然后呢我们进行不值，这次iQOO等于那这个是大的，就简单了，我不需要参数，我只需要调用这个类成员变量里边的打call就可以了，这个呢现在是第三个版本了，不到70，第二个版本呢是这个V2那是接口方法，注册方式，那具体的直线怎么用呢？很简单。6一个。你在放什么呢？没有，我靠。一点点。哪里这样的弟弟啊？一开始学慕课的课程了，学的什么呢？是因为具体的iOS怎么实现构造器的时候呢就输入了这是第三个版本。还有一种方式呢就更简单了不，不少器呢，使用起来了还不是太方便，比如说在里边啊，这个方式如果你这种小学学的，我们还要去new一个，因为这个输入方式只在构造的时候，因为在里面默认的单例模式，所以呢它的业务场景啊我们使用了。通常是造成摄影城，用三粒就可以了，做一次就可以，但如果在这个里面啊，如果还想学课程，现在呢只能在另一个一点出来，因为在里面并没有开放对iQOO就不用，那现在呢我们把它开放出去很简单。我太子里面给他画一下，那接下来呢我们接着写这个实现很简单心理。这样了就不依赖自己的不着气了，size iQOO算是一个JAVA号系列的20 study iQOO那学完课程之后啊，我想再学习一下前端的课程吧，三ix自考地点m也就是说里的具体执行学习的时候学习不课的课程他不需要关心，也就是说这个方法是不需要关心我学a还是b的，比如说我们第一种写法，我要关心具体的实现和标杆的方法呢和调用学习JAVA的课程方法和方法呢，要调用学习前端课程的方法。Ok我再转一下。输出结果呢我是一样的，那我们来看一下现在的内容。玩一下可以看到的三个具体的实现实现里呢，整个里边应用的类型。那当然说的第一层模块和高通模块不是看到这个图在上面那个，而是我们按应用层，例如mvc架构里面最上层和接收前端请求的可能是比收的，那他下一层呢。嗨所以这里边我们要体会一下面向接口编程和面向实现编程的最大区别，相信通过这个例子上，我们对依赖倒置原则呢也能有深，那当然这里边我们不用接口，用抽象类也可以，那抽象类呢也是一种抽象而实现的细节，例如地理实现接口或者继承。香味的实现最大体会的理解需要需要好直接呢主主要是地理是相对iOS的各类具体想学什么课这个类呢都不需要动，ok，我只需要在低层模块进行扩展。周一是扩展，我学什么课，我不会修改。比如说我现在学算法课开建起来的来的架构呢，一以细节为基础搭建起来的架构要准确的多，那我们抽象的目的呢其实就是制定了规范的QOO接口学习课程，这是一个契约，具体怎么实现交给具体的实现类，而高升模块地理是不依赖于具体的课程的实现，因为现在呢是这几个种类，说不定呢过一阵又出现什么新的语言了，那伊利这个类不用动其他课程的，现在也不能够只需要直线所以呢核心思想就是面相接口编程一定要记住面向接口编程，那理解了依赖倒置原则，对于理解对应的依赖注入控制反转，那就相当容易了，好，我们再看一下这类图，希望小伙伴们呢能认真体会依赖倒置这个原则。

---

3-5

现在我们来学习一下单一职责原则，我们先看一下定义，不要存在对于一个导致内变更的原因，那这句话呢怎么理解？假设我们有一个类负责呢两个职责。12，那一旦我们需求变更，比如说值得一相关的功能啊，需要发生改变，那我们再修改这个类的时候，有可能会导致原本变形正常的职责啊，发生故障，那这个就是因为我们在构建这个class的时候没有遵循单一职责原则。那个定义来说，也就是说对于这个Plus值得一和12这两个职责需求发生改变的时候都会影响这个，那也就是说这个class它存在两个值得，这两个职责都有可能发生变更，它存在两个导致类变更的原因，那这个定义呢就很好理解了。解决方案就是遵循单一职责原则，对于这两个职责呢分别建立克拉一和二分，别负责值得一和人格啊，那这样即使我们在修改class一的时候，对于负责职责二的class二呢也不会发生变更，也不会使他的发生故障，这样呢也就减轻了职责二所在的class二发生故障的风险，同理修改Plus二的时候呢也不会呢。好啦，手机发生故障防线ok，那单一职责原则呢？你现在哪几个方面呢？我们来看一下，首先人类个接口就方法体现在这三个方面，那对这句话就是定义的的一个累，一个接口，我一个方法呢是负责向职责，那对于他的优点呢我们来看一下降低类的滑度提高类的可能性，提高系统的可为不选降低变更引起我们一句一句来解读，首先呢降低的难度，一个泪只不得一项职责，那对于他的国际呢肯定要比负责多项职责简单的多提高类的可能性，那这个类比较简单，它也就更可能一些，同时呢也提高了系统的可维护性，那对于降低变更引起的风险不怎么看呢，首先变更是必然的，我们要接受变更，那如果单一职责原则遵守的好，改革功能处长可以显著降低对其他功能的影响，在这里边呢需要说明的一点是单一职责原则不只是面向对象编程所特有的，只要是某个画统一设计的都是用单一职责原则。那接下来呢我们就一起来扣点，在coding的过程中呢，我们一起来体会单一值得原则。

---

3-6

一包ok，那单一职责，那也就是说规定一个类应该只有一个发生变化的原因，这个呢是在内层次上的，那在接口层次还有方法层次上的也都要追寻单一原则。那现在我们结合一些例，一起来说明一下那单一职责的好处呢，首先是降低类的复杂性，提高可读性，提高维护性，最重要的是变更时风险率降低，那么现在呢结合例子一起来体会一下单一职责原则。首先呢我们现在有一个类叫鸟，这鸟呢主要的移动方式我们来写一下。默默的主要呢是用翅膀飞。我看这里边呢我们增加一个味。好，那这个类呢写完了我们再写一个测试类。另一个bird传进去一个大雁。大雁呐，用翅膀飞，那现在我再传一个。转一下。鸵鸟用翅膀飞，这不对，因为驼鸟呢，对不起，来到我们再看一下这个。，你要不要做一些判断呢？这个呢就非常符合我们日常开发，对于一个需求来说，我在这里边修改其实是最快的方式，那我们在实际工作中啊还要考虑开发的成本，时间进度带个等等，那完全遵守单元者呢，有时候还是真的要开始疫情况的，那但是呢我们有一颗按原则写代码的心，在条件允许的情况下还是希望大家来遵守。这些设计原则，那需求现在增加了头鸟，那么在原有的累了加一个判断。鸵鸟equals如果是鸟的话就拿过来。要走左脚呢用脚走那么乱，先看一下结果吧。Ok可以看到大雁没有问题，用翅膀飞，那头鸟呢，用脚走火鸟用翅膀飞，ok，那这里边呢我们有bug了，你要在这里面之后下一行又走到了这里，那这个呢就是一个典型的一个例子。那我们在扩展的时候，对于一些边界，比如说这里面我增加了艺术，但是呢下面并没有放到else，这种情况也比较常见，那正确的写法应该是这样的。那如果继续扩展下来，包括企鹅的企鹅呢也是鸟企鹅呀，也是用小狗，那鸟跟企鹅呢我们还可以细分一下，那如果现在再传来一些特殊的鸟类，那我们这个方法呀还要继续扩展，还记得这个张杰刚开始的时候呢说的三原则，其中有一个最主要的好处那就是变更时风险率，那现在呢是不遵循原则的，所以刚刚我们加了一个团长，风险呢还是比较大，那当然了，我们看到的这个方法比较简单。那实际的业务啊可能比这复杂，那边界呀，你这判断的啊要更多一些，那我们现在呢就从类的城市上来把这个倍儿的呀拆分开，我说创建一个类。是的，你把这个拿过来。我们再创建一个类。What？走路的，你把这个呀过来。那么test飞的和走的鸟呢进行一个区分，这段画一下。E二呢，还是比较简单的。咱们应用应用来判断这个，如果是大雁我们就用，如果鸟呢我就用行走的，那其实啊这个就是累的一个单一原则的一个体现，我们把一个类啊进行拆分。这样呢就使得每个类里面的方法职责是单一的，比较简单，也不至于呢，修改的时候啊引入新的问题，那我们来看一下内屏。等一下这类图啊还是非常非常简单的，你看一下，那现在呢我们这个类啊其实是由test创建这两个类，这个类呢现在已经不用了，那职责的在类的层次上还是比较清晰的，ok，那刚刚说的呢是累的资格上，让我们再看一下在接口这个级别上。是用我们的课程举例，这个呢是一个接口。Ok那在网站上的课程呢，我是可以获得课程名称的。Ok，我还可以呢，获得一个视频。拿到这个字节流，那还有两方法学习课程。还有退款Pro。那我们来看一下这个接口啊，对于课程来说，获得课程的名字，获得课程的视频。那在接口级别上来说单一原则，也就是说iOS这个接口啊可不是只有一个职责，首先他一个大值得是获得课程信息，比如说名字和视频直接流，那另外一个职责呢是管理课程和课程内容无关，例如学习课程，那如果我们学习课程就要获取内幕视频的字节流，但如果退了这个课程呢，可能就获取不了这个名字和，也就是说iOS这个接口啊可不是只有一个职责，首先他一个大值得是获得课程信息，比如说名字和视频直接流，那另外一个职责呢是管理课程和课程内容无关，例如学习课程，那如果我们学习课程就要获取内幕视频的字节流，但如果退了这个课程呢，可能就获取不了这个名字和，因为这个课程呢已经被我退掉了，那就是说退这个课程会影响课程这个接口的获取课程内容相关的变化，这两个值得呢是互相影响的，那现在呢这两个职责例如说我退了这个课程，那或许个人信息的时候啊，我们这个实现呀获取不到就可以了。那整体来，这个接口两个职责获取课程相关信息，还有呢课程管理上的一些处理，那我们就可以把这个拆成两个，一个呢是获取课程信息的一个接口，另外呢是课程管理方面的一个接口，我们来尝试一下。比如我们创建一个接口iQOO创建一个接口。课程内容，那我把这两个呢拿到这里边，对呀，这个关键字是然后把这个呢打到这里边。Ok我们再来比较，那现在呢我们来创建一个course的实现类。实现iOS manage这个接口，同时呢又实现这些。看一下这个时间内啊，实现了这两个接口，我们来了可读性，提高了也就更容易维护了，维护性的你就提高了，同时啊变更引起的风险，降低一个接口的修改，只对相应的实现类有影响，你其他的接口无关，这一点呢对项目的帮助非常大，那这个呢是从接口级别上来讲，单一职责，那刚刚呢累啊，接口啊，我们都讲了，那么再来看一下方法级别的。这个呢就比较简单了，一起来穿这个类。Mater呢用户名称还可以啦，更新地址，然后等于你address are ok，那这两个89啊，89好像是伪代码，再加认为上这个就是一个更新的一个过程就可以了，那其实这个方法呀就是说我来更新，就是任你同时呢更新地址，那如果一种写法我们用一个可变长包包包边的实线上的职责呢，就不是单一的，那更好的方式啊，应该是这样的。我们来看一下，首先我们还通过靠着这个方法，这样呢，大家可以理解他的一个变化。更新名字，那这个呢就叫update，有时你再看一下呗。那这个呢就叫62转。我们把刚才的那个方法才能两个方法。那如果我们需要更新，那就调用这个方法，需要更新的话就不要这个方法，这两种方法的职责是非常非常单一且清晰的，那我们再写方法的时候，经常的他会碰到这种场景。天呐，多了一个不玩。现在有点儿支行，我们来往这边拉一下，因为字体呢比较大，为了让大家看的更清楚，那这个方法里面传了一个布尔类型，这就有意思了，我你们一般都会这么写。第三次哪有事呢？3点ok，也就是说布尔类型要么二选一，那这个方法呀，其实他的职责一个是初度上还有呢度二，那这种情况下我们就应该把这个方法啊拆开。因为这个方法很明显的就是两个职责，除非这个传进来的布尔呢你没有使用，如果使用的话就建议拆开，因为有布尔类型，在这个方法名命名上可能啊也不会很好的能表达出单一的这个职责，这样呢开发起来简单，维护起来呢也容易。Ok，那我们来简单总结一下那个单一职责原则和接口方法的单一职责呢是一样的，但是呢我们在实际的项目开发中啊，很多类都不符合，这是因为呢我们在创建一些累的时候啊，包括依赖呀组合聚合这些关系受很多因素的影响，包括我们项目的规模。还有项目的，技术人员的水平，还有呢对进度的把控是否有deadline等等这些呢都是一个平衡的因素，那另外有一个考虑啊，也是就是说我们在扩展的时候，如果我们没有面向接口编程，而又非常良好的追寻单一职责，有可能呢引起类的一个爆炸那类的不了的比较多，所以呢我们在总结起来啊，就是说在实际的开发中啊，我们的接口和方法一定要做到单一职责，因为呢这个其实还是蛮好的，对于我们维护起来就会比较方便，同时呢它的成本非常低，那类的单一职责啊，追新情况就看实际的项目情况。那单一职责呢就介绍到这里，希望大家呢认真体会理解。

---

3-7



现在我们来学习接口隔离原则，我们先看一下它的定义，用多个专门的接口，而不使用单一的总接口。客户端不应该依赖他不需要的接口，那这个定义呢也非常好理解，在后边我们领着一起来coding的时候啊，很自然的就会理解他，我们接下来看一些要注意的点，那这个注意的点就是一个类对一个类的依赖应该建立在最小的接口上，也就是说我有一个大接口里边要有很多很多方法，那我们用一个类来实现这个接口的话，所有的方法都要实现。那这里边所说的类啊是一个泛指，比如说一个interface，那他呢也是一个类，ok，接着来看。建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少，那紧接着呢我们来看一下接口隔离。最重要的是注意的点，那就是适度原则，一定要适度，那我们刚刚也说了，接口中的方法尽量少。但是呢要有限度，那我们对接口进行细化，肯定是可以提高程序设计的灵活性，这个呢是毋庸置疑的，但是如果接口设计的很小，也就是说里面的方法过少则会造成接口数量过多，提高整个程序设计的复杂性，所以呢一定要适度，那么接着来看它的优点是什么呢？符合我们常说的高内聚。低耦合的设计思想，从而使得类具有很好的可读性，可扩展性，还有可维护性，那我们平时在设计接口的时候呢，只暴露给调用的类，它需要的方法，他不需要的方法呢则隐藏起来，只有专注的为一个模块提供好定制服务，才能建立最小的依赖关系。那这个呢就是从一定程度上减少了偶合。降低依赖关系，也就减少我和那提高内聚呢，怎么理解呢？减少对外的交互。使接口中最少的方法去完成最多的事情，那这个呢就是高内聚的一个体现，那我们运用接口隔离原则呀，一定要适度，这里边呢再强调一下，一定要适度。那接口设计过大或者过小啊都不好，所以我们在设计接口的时候，要多花些时间去思考和筹划，才能准确的实现这一原则。那在实际的项目开，在实践接口隔离原则的时候，我们也要考虑业务模型，包括呢有可能以后会发生变更的地方，那这些呢我们还要做一些预判，所以对于抽象我们业务模型是非常重要的。那接下来呢就领着小伴们一起来扣顶接口隔离原则相关的代码，小伙伴们就让我们一起来coding吧。E天呐，创建一个包接口隔离interface segregation。Ok那接口隔离值得呀，比较简单，我们写完例子呢再一起来总结一下，首先呢我们创建一个类。这个类呢是一，叫什么呢？animal？动物的一个行为，那动物呢有很多行为，例如说吃还有呢，还有呢游泳。不可能，那这个时候我们写了一个它的实现类，比如说到小狗来实现呐，animal action。看一下k首先狗吃是没有问题的，那狗的vivo呢，游泳也是没问题的，狗会游泳，那狗会飞吗？狗不会飞，但是我们实现这个接口，这必须得写的也就是说他可能，有一个，空时线放在这里边我们再写一个时间内。他也来实现action。那鸟的人都会吃飞呢，比如说驼鸟呢就会飞，那游泳呢也不一定，有的鸟呢会游泳，有的鸟啊不会游泳，那例如企鹅企鹅呢也算鸟类，它呢会游泳。但是呢不，所以在bird的这个实现里边呀，还是会有一些方法只能是空的实现放在这里边，那我们实际的开发过程中啊也经常能碰到这样的情况，对于一个接口里边声明的东西。并且呢他们是不同类型的那么来看一下例图，首先这个呢是现在的一个类图，去淡化一下。还是比较清晰的，只要实现animal action dog是平级的，这三个方法是必然要实现的，ok，那我们现在呢？把这个版本啊进行演进，我们再声明一个接口叫ifly。还x这里边呢我最大化一下。有一个方法是black，我们在上面一个i eat。Animal action这个呢是一个接口。你在哪有一个吃的方法，ok，那再写一个iframe animal action。那可以游泳。那我们的到实现什么呢？我们把现在呀这个类的实现删除掉，首先它可以游泳。他那还可，我们来实现这两个接口，我们来看一下，那么如果这样写的话，dog是不需要写的实现的，只需要写例子，还有m的实现就可以了，我们来一下列图就让画一ok那很多小伙伴们都想刚刚我们讲了三一职责原则，那这个接口隔离原则和那个是不是很像的那这里边呀？一下他们的区别，首先呢单一职责原则指的是类接口和方法的职责是单一的，强调的是职责，也就是说在一个接口里，只要职责是单一的，有多个方法也可以有十个方法，20个方法，比如说吃这种呢，有很多吃法，对吧？开发中开发中啊些点啊，接口尽量小，没有问题，但是呢要有限度，如果太小的话，那接口数量过多，设计呢也会变得更大。也要适度，所以呢只要社原则和包括后面讲的设，其实我们在实际使用的时候要选择一定的平衡结合项目的各个因素，还有呢你这个项目的这个规模，另外一个注意的点呢就是提高面具减少对外的交互是接口用最少的方法去完成最多来认真体会一的事情，那运用接口隔离原则还要再重申一遍，一定要适度口设计的过大后过，所以在设计接口的时候，在抽象的时候只有呢多花一些时间去思考，才能准确的实现对原则，那另外再强调一个是接口呢下是设计师对外部约定了契约，那我们通过把animal action分散成三个不同行为的mx配预防啊外来变更的一个困难。哎那提高了我们这个系统的灵活性和可维护性ok那接口隔离原则呢就比较简单希望大家通过这个例子嗯

3-8

张姐，我们来学习。小伙伴们，大家好，这里这章节我们来学习迪米特原则有效，迪米特原则的也有叫奥吉米特法则的，还有呢叫最少知道原则说的呢都是同一件事情，我们现在呢先来看一下定义。一个对象应该对其他对象保持最少的了，又叫最少知道原则，尽量降低类与类之间的耦合，那迪米特主要强调的就是降低耦合优点呢也自然是降低类型间的吻合。那从代码层面呢我们可以考虑一下，最少知道，也就是说该指导指导，不该知道不知道，尽量呢不要对外公开太多的方法和非静态的变量，尽量呢内点多使用private包权限，还有protective等访问权限，那迪米特原则的核心观念呢就是类之间的结偶，那偶呢是有一定程度的，我们可以认为我们只有藕合越低，累的不用率才可以提高，那因为我们减少了每个类之间不必要的依赖，从而达到降低耦合的这个关系呢，凡事都要有个度，之前呢我也有强调，那如果过分的使用迪米特原则呢会产生大量的中介类，导致呢系统变复杂，为维护呢带来了难度。所以我们在使用低比特的，要反复权衡，既要做到结构清晰，要做到也有和高内聚，那我们平时在业务编码的时候啊，经常碰到一种场景，也就是说一个方法我放到a类也行，放到b类也行，那这种情况应该怎么做呢？我们可以坚持一个原则。那如果一个方法放在本类中，既不增加内间关系，也对本类呢不产生负面影响，那就可以放到本类中，那一会儿呢我们在coding的时候啊也会领着大家来看l内图。还有呢就是通过in来判断一下厘米特的使用情客原则主要强调什么？强调只和朋友交流，不和陌生人说话，那这里面呢我们就要讲一个概念，朋友在迪米特原则中什么是朋友呢？出现在成员变量方法的入参出餐中，这里面的类呢称为成员朋友类，而出现在方法体内部的类是不属于朋友类的，不和陌生人说话，也就是说不该了解的累就不要和他说话，那现在呢？起来coding吧。那迪米特法则呢知道原则，那最少知道原则呢就比较好理解了，我不应该知道的，我就不应该知道，那这句话呢听起来下一句废话，简单的理解，它的表现形式呢是我对外部引入的越少越好。但是目的和结果是一致的，都要完成这个类甚至方法的一个职责，强调的是只和直接的朋友交流，那我们每个类呢和其他对象肯定是有偶合关系的，那朋友关系呢，组合聚合依赖等等这些关系都可以称之为朋友关系，厘米特的初衷呢就在于降低类之间的耦合，每个类都尽量减少对其他类的依赖，这样呢还比较容易使系统的功能模块儿得到独立。相互之间不存在或减少依赖关系，提高内聚。那我包迪米特，ok，那现在呢我们有一个业务。比如说扑克网是有大老板的，大老板的这一天呐变一个team leader，说你给我查一下到现在为止线上有多少个课程，那这里边呢沃尔西道几个类boss team leader还有课程course，那我们先写一个boss，ok，然后再写一个course。Ok再创建一个team leader。现代化一下，首先boss在里边呢有一个方法价值量很慢的。那连起来呢就是隐藏了，就是查课程的一个数量，那方法名字就叫这个了，这里边呢传入一个频率的。对，team leader下去没有让他查课程的数量，那现在这个boss呢对价指令我们查一下课程的数量，首先呢说实话一下课程。不值又一个。打小包。那现在呢开始查处这里边呢就把它处置化到这里一个一个查，那假设呢这里边用了一个比较笨的办，下页，下页艾叶茶，而没有啊，写一个搜狗直接从数据库中拿出来，所以呢我们模拟一下一页一页茶树，那小时候呢我们也听过煮鸭子这个儿歌。我们采用和《数鸭子》一样的方式来数课程。假设20个，然后呢直接往里边啊直接爱爱的一个QQ对象放到这里边，那么现在呢在进入team leader这里面呢肯定有个boy check number 2号加个复数，这里边呢就直有课程啊，集合啊，进来ok整个输出在线课程的数量是？Beast点ok，非常简单。那然后呢我们再回到过几天在这里边呢，我就要调用。还不是方法，ok，然后呢把这个集合产进来。现在呢我们来创建一个应用层的测试类。Ok，那这里面的逻辑啊也非常简单，我们直接在主函数里面写。首先你有一个boss有一个挺立的。时候调用bo number，a team leader传进来，ok。这team leader下质量查一下数量，那我们转K结果呢已经出来了在线课程的数量，那写到这里呢，有的小伙伴们会认为我们这么写，其实也没什么问题呀，那我们一起来分析一下，看看到底存不存在一些可以，改进的点但我们看，一下boss的方法，啊之前呢我们也强调过迪米特法则呢主要讲的是盒直接的网友交流，比如说team leader做一个他是直接的朋友，那朋友的定义呢就是出现在那个同学变量里，比如说后期里面的有一个类成员变量，关联关系呢就会出现在内存的变量里，还有呢方法的入参。例如leader还有那个返，也就是说方法的输入和输出也都是直接的朋友，只不过现在呢我们这里面是一个而方法，例如这个course这个来你们这并不是的朋友，所以不是boss的朋友直接给team leader下指令，team leader查完之后直接把结果给boss就可以了，boss不需要关注，他和team leader是直接的关系，不应该和陌生的发生交流。那目前的这种写法呢就违背了迪okOk，那这个呢其实是在某些情况下一种判断的一种方式，那我们看一下类图。我们看完猎头啊，就是比较清晰，同时呢我们在观察他们之间的变化，包括我们改变之后呢就可以直接画一下。这些方法呀都打出Ok买的呢，我们往边上转test应用层的，他来创建team leader和boss，ok，他在边上主要是看这三个。我重新排版，这样呢会更清晰一些，那这个排版呢是idea自动排版的，根据呢需要展示的不同元素，它会自动排版，那这个排版呢就比较清晰，我们来看一下course不应该是由boss来创建的，而是应该有leader的。这条线指向COS的那个箭头应该从leader来指向他，ok，这个就是从ul角度来分析的厘米特法则，那下面呢不用看的呢是应用层，我们把它认为的这个客户端他来教啊，整体的这个服务他来创建。你的这个呢忽略主要看他们仨之间的一个关系，ok，那我们现在呢来修改一下，实现首先进入boss里边把这个呢拿走boss类里边的这个方法呀，不再需要了解并知道cosplay了，而把这个呢挪到这里边。Ok，这个时候这个入差呀就可以干掉了。这里边参数也不用传了，ok，我们看一下现在的boss就清爽多了，下指令给team leader下指令team leader直接查boss，不需要了解这个类。然后team leadCOS类发生接触，他来查具体的课程数量，ok，那c类呢我们不变，我们回到太子里边这个写法呢也没有变化。我们现在呢直接转一下，结果呢是一样的，可以看到我们遵循这个原则之后呢在某些业务场景下应用成代码呢是不需要变化的，ok。当然碰到业务复杂的场景了，有可能需要变化，那目前从太子里边我们看不出来变化，那我们看一下这边呢就很清晰了，ok。我们看一下它的还是它来创建两个，这个不重要，主要看这里COS现在是由team leader来生成的，ok，不再和boss也不需要知道好进好进行开发的时候呢也就游刃有余了，那希望小伙伴们通过学习比米特法则，在我们日的工作和学习中呢都可以适当的运用起来。







# 设计模式简介

创建型模式: 帮助我们如何来精巧地创建对象

结构型模式: 在软件结构上, 通过重构以及抽象让软件结构更有条理更易维护.

行为型模式: 针对现实中某种业务场景, 针对这种行为做的设计与优化.

创建型模式是其他模式的基本

---

创建型模式: 工厂模式

结构型模式

行为型模式



# 工厂模式

创建型模式

* 工厂模式用来隐藏创建对象的细节. 很多类似的类, 实现的工作都基本相同, 用一个类来帮助选择需要的类.

* 工厂模式核心：工厂类（Factory). 一个中间人的角色, 来帮助我们选择指定的类来创建对应的对象. 中间人 -> 工厂类

获取一个对象, 不是new出来, 而是通过工厂类进行创建

* 工厂模式根据行为可以分成: 简单工厂, 工厂方法和抽象工厂. 目的都是问了隐藏创建类的细节, 但是实现的理念不同. 简单工厂: 最简单, 使用最广

## 简单工厂

场景: 买苹果, 以前需要了解每个苹果的特性对应的牌子(红色的甜(红富士), 绿色的酸(青果)). 水果商家, client对商家提出我要买什么样子的苹果, 红的甜的, 商家来进行处理

<img src="img/design-pattern/image-20211229220618935.png" alt="image-20211229220618935" style="zoom:50%;" />

以前每个Client都需要了解每个具体类的情况

但是引入工厂后, 根据Client的要求, 由工厂类创建就可以了, 

<img src="img/DesignPattern/image-20211229220711760.png" alt="image-20211229220711760" style="zoom:67%;" />

对于原始的具体类, 因为都是相似的, 所有抽象出来一个具体的接口, 再创建一个工厂类, 根据客户的要求(传入的参数), 由工厂类来自动创建对应的实现类, 返回适合的对象. 客户类不再面向具体的实现类, 而是持有抽象的接口. 因为每个类都实现了这个接口, 工厂类返回的时候返回的也是接口, 而不是实现类. 对于Client来说, 不需要关注工厂类创建了哪个具体类, 只需要知道工厂类返回了某一个接口即可.

---

项目应用: i18n国际化. 简单工厂实现

两个人来开发, 一个开发Software整体调用. 一个开发具体的语言类. 

每个语言类都会输出对应语言的"人力管理系统"

```java
public class Chinese implements I18N {
    @Override
    public String getTitle() {
        return "人事管理系统";
    }
}
```

```java
public class English implements I18N {
    @Override
    public String getTitle() {
        return "HR System";
    }
}
```

如果直接这样子暴露给开发人1, 那么开发人1就必须知道每一个类的情况, 了解各个语言, 痛苦

开发人员2了解语言, 所以做一个抽象接口出来, 将这些语言类都实现这个接口

``` java
// Internationlization
public interface I18N {
    public String getTitle();
}
```

并且又提供一个Factory工厂类, 提供静态方法. 简化对象创建的过程

```java
public class I18NFactory {

    public static I18N getI18NObject(String area) {
        if (area.equals("China")) {
            return new Chinese();
        } else if (area.equals("English")) {
            return new English();
        } else if (area.equals("Spain")) {
            return new Spainish();
        } else {
            return null;
        }
    }
}
```

对于开发人员1, 直接面向这个工厂类开发就可以. 我不需要知道语言是什么意思, 只需要知道区域的名字, 也不用关心这个I18N是哪个类实现的, 只需要直接调用方法输出即可

```java
public class Software {
    public static void main(String[] args) {
        I18N china = I18NFactory.getI18NObject("China");
        System.out.println(china.getTitle());
    }
}
```

注意点:

1. 原始类都需要实现相同的接口. 这里的所有语言类都实现了I18N接口
2. 使用的时候, 无论是工厂的方法还是产生的对象, 都是面向接口的. 由工厂类来查看具体的实现类, 并返回对象

```
I18N china = I18NFactory.getI18NObject("China");
```

3. static描述了工厂, 静态工厂. 因为使用了static描述, 使用的时候不需要new Factory, 直接调用对应的静态方法, 简化开发

---

工厂模式: 额外增加工厂类, 隐藏具体类的实现细节, 使用者不关心底层的创建逻辑, 只需要知道工厂和创建对象的方法返回对应的接口即可.

开发人员1和国际化开发人员2之间分工更加明确, 解耦, 我不需要关心国际化的开发, 只需要根据工厂类获取对应的对象即可. 





##  工厂方法







## 抽象工厂









---



# 建造者模式









# 单例模式







# 原型模式





# 外观模式









# 装饰者模式







# 适配器模式







#  享元模式









# 组合模式







# 桥接模式













# 代理模式







# 模板方法









# 迭代器模式









# 策略模式

## 定义与类型

定义: 定义了算法家族, 分别封装起来, 让它们之间可以互相替换, 此模式让算法的变化不会影响到使用算法的用户.

类型: 行为型

也就是不同的算法封装到不同的类, 相互之间可以替换.

实际应用: 田忌赛马, 怎么去赛马就是策略. 还有促销满减, 返现等也都是促销的策略

实际的应用: 可以大范围的处理掉if Else. 也就是说如果每个方法里面有大量的if else或者if else if, 可以通过策略模式给他们消除掉

## 适用场景

* 系统有很多类, 而他们的区别呢仅仅在于他们的行为不同. 
  * 使用策略模式可以动态的让一个对象在许多行为中选择一种行为, 也就是说这个对象不同的行为放到不同的类中, 它有很多行为类, 而每一个行为呢对应每一种策略

* 一个系统需要动态的在几种算法中选择一种
  * 这里边所说的算法就是策略, 因为策略中封装的就是一系列业务逻辑和计算方式. 比如说两个数字, 通过加法策略就把两个数字加到一块, 通过减法策略就做减法.

## 优缺点

### 优点

* 满足开闭原则
  * 可以不修改原有系统的基础上选择具体的行为. 这种行为我们也可以扩展. 这里的"行为"例如上面的加减乘除的算法

* 避免使用多重条件转移语句(if...else, switch等). 把具体的策略行为分离成一个一个单独的类替换ifelse中的逻辑. 降低代码耦合

* 提高算法的保密性和安全性, 只知道这个策略是干嘛的, 不需要了解这个策略里边的内部实现
  * 封装了一个促销的服务, 对外提供不同的策略. 客户端在使用的时候只需要使用double的接口, 而具体的策略实现的是放到这个double的provider上.
  * 在具体的策略类中, 封装了不同的行为和算法以及的相关的数据结构, 对于客户端来说是不需要客端知道里面的内容

### 缺点

* 客户端必须知道所有的策略类, 并自行决定使用哪一个策略类。
* 产生很多的策略类
  * 把不同的策略封装到一个方法里面, 通过大量的ifelse来判断, 都写在一个类里面. 如果拆出来一个类一个行为, 一个类一个策略. 会产生很多的策略实现类

## 相关设计模式

### 策略模式和工厂模式

工厂模式包含扩展方法以及抽象工厂, 工厂模式是创建型的设计模式, 策略模式是行为型的.

也就是说工厂模式接收指令, 创建出符合要求的具体对象. -> 策略模式接受已经创建好的对象, 从而实现不同的行为.

### 策略模式和状态模式

他们有什么相关性与区别？

在使用策略模式的时候, 客户端需要知道到底选择哪一个策略, 而我们在使用状态模式的时候, 客户端不需要关心具体的状态, 这些状态会自动转换.

总结来说, 如果系统中某个类的对象存在多种态, 那在不同状态下的行为有差异的话, (例如: lol中有buff会浪, 没buff就稳.), 而且这些状态可以发生转换时, 可以使用状态模式. 

那如果系统中某个类的行为存在多种实现方式, 如说618和双十一的促销不同策略, 促销是一个行为, 而这一行为有多种实现方式, 这种情况下我们就要使用策略模式.

## coding

### 普通方法

促销活动, 促销是课程的一个行为促销行为, 这个促销行为有多种实现.

首先创建一个促销策略接口PromotionStrategy

```java
public interface PromotionStrategy {
    void doPromotion();
}
```

然后创建具体的实现类, 表示不同的促销方法: 满减(ManJianPromotionStrategy), 返现(FanXianPromotionStrategy), 立减(LiJianPromotionStrategy)

```java
public class ManJianPromotionStrategy implements PromotionStrategy{
    @Override
    public void doPromotion() {
        System.out.println("满减促销,满200-20元");
    }
}
```

```java
public class LiJianPromotionStrategy implements PromotionStrategy {
    @Override
    public void doPromotion() {
        System.out.println("立减促销,课程的价格直接减去配置的价格");
    }
}
```

```java
public class FanXianPromotionStrategy implements PromotionStrategy{
    @Override
    public void doPromotion() {
        System.out.println("返现促销,返回的金额存放到慕课网用户的余额中");
    }
}
```







---

我新建一个包。让我们引入一个业务场景，拿博客网来说啊，博客网的课程呢在618和双十一的时候呢会有各种促销活动，那促销的是课程的一个行为促销行为，但是这个促销行为呢有多种实现，我们这个业务场景呢就是刚刚说的顾客网的课程促销。我感觉那很简单，我们首先呢创建一个接口，接口是什么呢？促销促销策略这么一个接口，就再换一下这里的方法。中国是不是进行那么这个名后边的声明的时候使用它我们创建一个新类，这个类呢叫满减。促销策略，ok，你要的，然后呢再创建一个递减。促销策略，然后再创建一个。返现促销策略？ok，这里边说一下啊，返现比如说买一个200元的网课，返20元放到了客户的余额当中，这个呢是返现立减呢，比如说买一个200元的课程，立减20只需要支付180元，这个呢是立减，对订单的金额没有限制，而这个满简单，比如说把900-300，我们买了几个课程。888，那不买900的也不会享受这个促销优惠，那么最大化一下，嗯，嗯，那就拿返现来说啊，嗯，让他实现Pro promotion这个销策略，然后呢实现里面的方法做促销，那么直接输出返现促销。返回的金额与存放，嗯，嗯，不知道顾客网本来有一个的，我一般都会。然后呢是历险这个策略实现实现主销策略，就是我说递减促销是课程的价格直接减去配置的价，如果呢我们把每个课程递减的金额呀做成配置，或者呢换到dm中或者呢做一个动态配置或者呢他一定百分比等这些呢都是这里边的具体的实现，只不过呢我们这里面简单来写，围绕的还是设计模式。实现的只有一行，我是第九行，然后再看一下满减出来同理的他来实现促销策略，现里面的方法做促销。呵呵，满减促销。满200-20元，然后呢我们来包装一下这个策略，比如说我们现在呢有一个类，这个类呢是一个名词。活动promotion activity创建这么一个，这个换一下。那这里面呢你要把策略呀放进来促销策略，然后然后呢我们通过不到期输入。下面呢我我下，我们这个呢是一促销活动的类，这里边呢它有一个行为。执行具体的促销策略，ok，然后呢调用这个促销策略的都promotion方法就ok了，非常简单，现在呢我们来看一下l内图。给他换一下。打开所有的按钮，然后呢还有他们之间的关系放大一下，然后在这个图啊非常清晰明亮，这个呢是一个策略接口，里边呢是三个具体的促销策略，右侧的是促销活动，这俩呢那一个促销活动当中包含一个促销，ok，那这个促销活动呀，我们还可以用它作为课程的一个成员变量，那这样呢？这个课程的促销活动具体使用的哪个策略呢？这些关系就都建立起来了，那我们这里呢主要围绕策略模式，课程这个类啊，我们就不创建了，只不过呢创建课程这个类之后，我们还要把这个促销活动类作为课程类的一个成Ok，希望这些伙伴们通过之前的课程看ul尤其的策略模式，这么简单的url肯定是非常轻松的，那么接着回来。现在的你写一个测试类，我可能最大化一下，写一个函数，明天在这里面呢，很简单，比如说activity促销活动，我们现在呢有一个618的数学活动。创建一个promotion促销活动里边放什么呢？在618的时候我们使用立减这个策略。然后呢我们再声明一个。双十一的活，嗯，这里面呢嗯那双十一呀也是一个比较大的网购节，还有那网站呢为了提高复购率，提高粘性，使用了返现这么一个促销策略，把这个钱呢存到用户的余额当中，ok。因为他这个时候我们调用六八这个活动promotion这个方法，然后呢再调用一下双十一的这个活动的。执行什么乱一下看下。我知道了，非常简单，结果呢已经出来了，比如说在618的时候执行的促销策略呢是递减促销课程的价格直接减去配置的价格。而双十一的时候呢执行的是返现促销，把返回的金额呢存放到扑克网用户的余额当中，ok，那通过这个应用层的代码我们可以看出来11行和12行呢是不需要化的，唯一呢是说应用层在不同的促销阶段选择不同的促销策略即可，其他的都不用动，ok，那如果我们现在要新增一个策略也很简单。比如说我们现在呢新增一个策略叫反代金券策略嗯那如果我们不通过策略模式的话，我们在这个应用程代码里面呀。可能就要进行各种的一个判断，而这里判断的实现就是把现在不同的策略里边的实现呀拿过来。放到里面呀形成一个比较大的一个方法，但是呢我们这里边啊实现只有一行，那实际的业务当中肯定不是一行，所以呢就会导致某一个方法里面的代码不多，方法过大，这些呢都不利于以后的维护。以扩展，那这个呢是策略模式的初级，如果呢这里是service逻辑，可以看到这里边呢每次调用的时候只要另一个不要活动以及呢对应的促销策略，而且具体的呢是618还是双十一的，我要显示的写的代码里，现在呢我们来演进一下，现在这种写法的策略模式呢并不能完全消除else，例如呢我们来做一个测试。copy过来。你们这里呢就断点去掉，我们首先呢创建一个promotion activity，而他呢是什么呢？先生命一个，ok，然后呢我们创建一个算一个什么呢？那这，嗯，嗯，嗯，好了，对于理解，嗯，我们这里呢就不声明成常量了，ok，大家理解是这个业务场景就ok了，下面呢我们删除，那你现在这种代码结构，我们在写业务逻辑的时候也会避免不了这种写法一。做一个判断，有t我们就阿帕奇包下边的echo，可能这就是老夫老妻的。如果呢就是我身体是立减的话，我就创建一个等于你有一个activity里边呢肯定有一个递减和那边。还要继续写else if这里边呢，如果或者返现的话，我们就用返现。红里这里边呢还会另一个模式activity这里边就是返策略，我也不敢，还有呢。点点，点点，点点，最后执行一下promotion activity的execute。我们先来转一下，看一下Ok结果出来了，我因为我们传的是立减，所以呢命中到这里面，所以呢执行了立减注销对面呢我们思考一个问题啊，最大画一下，嗯，也就是说我们的业务逻辑代码每次到这里边都要有一个对应的策略以及那种对应的活动。那其实这些策略目前我们这种声是写成安全的，也就是说在我们这个业务逻辑代码里边并没有使用对应的变量。但是呢如果使用的话，那就是另外一回事情了，ok回来。我们不需要每次命中力减策略的时候都来创建一个系统的意见策，所以呢我们这边为了消除这里的else以及避免多次回复的重建对象，我们结合我们和策略模式一起呢把现在的代码在眼睛我们首先创建一个策略边的列名啊，我们直接复制，就是包括我们部门有促销的策略工厂，我看到他今天送了我点那个最大化一下，首先我们生命一个哦。卖你知道？就对应的value呢，就对应promotion促销策略，我们的他应该还没问你，这里面就有，我跟你说你那个小的可以说那我用的是idea里面的eclipse对应我用的x大小写切换又有一个卖木。阿希曼去了就是去？然后呢我们在静态块当中把这个都听到线上，你听到这么说，你想象一个这个，然后放什么呢？因为我的对应的策略我估计我们见过面，是吧？你还有其他的相策略，感谢。？然后呢我们在静态块当中把这个都听到线上，你听到这么说，你想象一个这个，然后放什么呢？因为我的对应的策略我估计我们见过面，是吧？你还有其他的相，还有呢满减，ok，那这个t啊，一会儿我们再写切回来。它本身这个工厂是不希望在外部能溜出来，所以呢把他的构造器改成原味的，然后对应开放外部的是一个工厂里边的获取营销策略方法。所以呢我们在写一个方法study，我们中心有一个就是法规值是什么呢？对应的测量。就是，快看这里。Promotion 5t不打了。对应的如陌生策略的从这个map里面获取，你当时边的key呢就是他ok，如果里面没有对应的营销策略，如果是空的先再问一个，如果为空的就反应，那否则呢就把它本身带回回去再看。那对于我们企业项代码的时候啊，如果这个策略呢是一个空策略，想象一下为了对调用我们的方法的逻辑的更加友好，那么这里呢就不返回到了，防止呢它出现空指针，所以我们创建一个空策略也很简单。和之前的创建方法呀一样的感觉，让他来实现促销策略。嗯，重新里面的实现，我当时不错，项目，嗯，ok。那么接着回的快，里面这里面的规定规规定规定感冒就好的，然后呢那个那里去过来那个语音是这样的，我们这个方法的时候里边的对象包括这些，还有呢我不会丢了，现在呢我们把这个里面的t先充上。他说应该很直接创建在这边，我们就加吧。好看就特别好，这里面哪个好诶，这个是一个就像我，我现在没那不这种电商一期，二期当中啊有几行在声明常量的时候呢，它可以起到一个逻辑上分组的一个作用。那那这里边默认的它也是可以看到，如果我们家的话呢，也就是说这里的值呢是不可更改的，先把它呢删除掉，然后呢我们把这些key全充上。Promotion key点，这个呢就是以前他挺遥控下边是返现，这个呢是满减，ok，那现在就写完了，当然如果我们不在被加载的时候就把这个卖了钱充上的话，我们也可以使用类似小圆模式的，就是只不过呢这个业务产品中是没有必要的。而这个呢也是促销策略工厂的一个简单实现，那么接着回到太子里边注意看现在的这个业务逻辑代码，我们再copy一个，然后呢把上边的50上把那个窗砸掉，门可以装吗？下面的实线呀就非常简单了，这些都可以删除掉这么小的吗？那是外部传过来的，假设呢是一个外部方法调用的时候传过来的，然后在这里面我们直接就有另一个Pro里边的很简单调用，然后get promotion对应的策略把传进去。然后执行就可以了，我们直接转一下。Ok看到，如果把这个改成满减的话，看一下效果，如果这里边是一个不存在的促销策略的，这一下返回的就是一个无促销的这么一个策略，ok，那通过工厂和策略模式的一个组合使用呢，我们把上边这些就消除掉了，非常，那这个呢说下来这个方式啊，主持上，然后把最原始的打开你的这个好朋友策略模式部分我们就讲完了，希望通过我们这个眼镜这么一个步骤呢，是小伙伴们能充分理解。策略模式一般使用的方式呢并不是独立使用的，可能要结合单例，结合工厂，结合想源。这些方式一起来实现一段优雅的业务逻辑，那希望呢校办们通过顾客网课程促销的这个场景呢，能对策略模式有更深刻那以后呢，如果我们在项目当中碰到大量的，我们可以考虑是否可以抽象这个对象以及他的行为来把他封装成一个策略模式。或者是说个对象的行为经常的要变化，扩展性的要求比较高，这种时候也要考虑一下策略模式是否合适。当然了，具体的使用还是要看实际的项目，有常见的。成都城市







### 简单策略模式









### 工厂模式+策略模式











## 源码解析







---

19-3

这JAVA的原生提供的在JAVA有qo包下呢是一个比较器，那在加了很多集合框架当中啊，我们需要传入一个比较近，而这个比较近的默认的有很多实现。我们也可以自己实现，我们想要的比较气，比如说我们按下ctrl加t可以看到无论是在瓜瓦当中还是呢spring当中还有呢发型当中，比如说这里边它自己实现了一个布尔类型的比较，下面还有很多。都可以自己来比较器，那我们在具体的业务场景来说，比如说他可能包括价格评分，购买人数，浏览量等等同的因子都是有不同的权重，然后呢加到一块儿算一个总分，那我说的呢是一个比较简单的排序啊，是用这个比较器来实现，当然了实际过程当中啊可能会使用es来实现这个排序，只不过呢也就是说比较气在具体的业务当中还是要根据业务来写自己的一个实，那这个比较器呢就是一个策略，例如呢他提供我们拍这个接口，还有呢echo所有的策略呢都要实现这两个方法。那这个比较细，就相当于一个抽象的策略，这些呢都是具体的策略，那刚刚也说我们经常呢要把这个比较器传入过去，传入到哪里呢？我们看一个arrays。这个类呢需要办美，经常来用，比如说这里边呢最常用的salts。最下边我们看一下这个，这个呢是一个排序，然后呢参数就一个比较器，也就是说我们实现了一个自己的比较器啊，可以传入过来，然后呢就会按照我们所实现的比较逻辑来进行排序，在这个方法实践里面呢把这个比较器啊继续往下传，ok。那这些呢就是策略模式在阶梯中的典型应用，那么再看一个类催慢。这个呢会更形象一，例如刚刚的我们促销活动里边呀，有一个促销策略对象，而在map里边呀就有这个比较器对象，而催麦粉里边的具体的compare。这么一个实现的，我们可以看一下，对比较器呢又进行了一些应用和加工，ok，非常容易理解，那这个呢也是策略模式在jk中的典型应用，那么再看一个spring当中的对上注意这个包啊，选择spring framework下边的。这个啊小伙伴们可能不经常用，但是它的时间内我们可能经常用，比如说这里边呢有一个class pass，还有呢文件。Five还有呢url等等各种也就是说spring呢通过resource这么一个接口提供了资源访问，而这个resource就可以理解成是一个策略的抽象，那于来说他呢是同一个对象，但是访问resource的行为有很多种，所以呢这下边都是访问resource的一个具体策略行为。那我们来看一下它的主要接口，比如说是否存在呀？是否可读啊，还有呢获取它的url，获取它的UI获取的，那我们平时在主函数中或者呢写试的时候，经常啊通过main来加载spring的容器，这里面呢就要使用的具体的这个resource的具体策略实现类，他在spring当中避免的初始化也使用了策略模式，那就是这个类。Strategy通过名字的我就看出来，他呢是一个初始化的策略接口里面呢有几个方法都是围绕初始化相关的，那么再看一下它的实现有哪些呢？有两种，一个是简单的初始化。策略还有呢cg lip子类的初始化策略，我们打开简单的初始化策略来看一下，那在这里面呢就实现了刚刚在接口中声明个初始，并且呢又增加了这两个可以看到，那这个类呢就是具体的策略实现类，比如说，对于病人来说，这个对象可以初始化，初始化呢把它定成一个策略，而有两种策略方式，一种呢是简单的初始化策略，还有一种呢是cp子类的初始化策略，那么还可以看一下它具体的应用。比如说这个接口呢在哪里使用了呢？可以看到在抽象的这个中就使用了这个策略作为返回值，那有兴趣的要办的可以进来仔细看一下，这里面呢还要说一下这个简单的初始化策略类，它呢还是cd lib的父类，我们看一下，也就是这里CD lib子类的。初始化策略呢又继承了简单的初始化策略，那它继承了简单初始化策略，也就代表着cp这个类的，它也会实现这个初始化策略接口ok，那这里面呢就展示了另外一种实现策略和策略之间可以存在一个继承Ok，那这个呢还是要根据我们实际的业务场景来选择性的应用，例如我们刚刚一起的场景啊，那些策略之间处于同一个level，而在spring源码当中，这个初始化策略下边两个策略之间就存在继承关系ok，那刚刚那些呢就是策略模式在jk和当中的一些应用，希望呢需要办满，能理解透，掌握好，ok。





#  解释器模式





# 观察者模式







# 备忘录模式



# 命令模式







#  中介者模式







# 责任链模式





# 访问者模式





# 状态模式



# Ref

* [imooc-Java设计模式精讲 Debug方式+内存分析](https://coding.imooc.com/class/chapter/270.html#Anchor)
* git代码, [jinchuanchuan/Java_Knowledge_Summary](https://github.com/jinchuanchuan/Java_Knowledge_Summary)













